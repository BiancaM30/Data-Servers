select sysdate from dual

SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') FROM DUAL

/*1. Cu instructuni CREATE TABLE se cere crearea a cel putin 3 tabele, sa exista cel putin o 
relatie m <-> n, si definirea de restrictii de integritate pentru aceste tabele:  
    - restrictii de cheie: unica, primara
    - restrictii pentru valorile coloanelor   
    - restrictii pentru valorile inregistrarilor   
    - restrictii de cheie externa

La tabele si coloane sa se asocieze comentarii (descrieri). 
La alegerea problemei se va avea in vedere faptul ca aceste tabele vor trebui modificate prin 
adaugarea unor coloane cu valori de un p definit de utilizator. Pentru tabelele definite se cere 
crearea de indexuri relevante; se vor pune comentarii legate de alegerile facute . (1p) 
*/

CREATE TABLE MBMBD1R31.cafes(
    cafe_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    cafe_name VARCHAR2(50 CHAR) NOT NULL,
    address VARCHAR2(100 CHAR) NOT NULL,
    cafe_size NUMBER(3,0) NOT NULL,
    nr_tables NUMBER(2,0),
    nr_employees NUMBER(2,0) NOT NULL,
    
    CONSTRAINT cafes_pk PRIMARY KEY (cafe_id),
    CONSTRAINT cafe_size_ck CHECK (cafe_size > 30),
    CONSTRAINT nr_tables_ck CHECK (nr_tables >= 0),
    CONSTRAINT nr_employees_ck CHECK (nr_employees > 0)
);
COMMENT ON COLUMN MBMBD1R31.cafes.cafe_size IS 'size is computed in square meters';
COMMENT ON COLUMN MBMBD1R31.cafes.nr_tables IS 'a coffee shop can have 0 or multiple tables';


CREATE TABLE MBMBD1R31.suppliers
(
     supplier_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
     supplier_name VARCHAR2(50 CHAR) NOT NULL,
     address VARCHAR2(100 CHAR) NOT NULL,
     website VARCHAR2(50 CHAR) UNIQUE,
     delivered_products VARCHAR2(50 CHAR) NOT NULL,
     rating NUMBER(1,0), 
     
     CONSTRAINT suppliers_pk PRIMARY KEY (supplier_id),
     CONSTRAINT delivered_products_ck CHECK (delivered_products IN ('supplies', 'coffee', 'espressors')),
     CONSTRAINT rating_ck CHECK (rating BETWEEN 1 AND 5)
);
COMMENT ON COLUMN MBMBD1R31.suppliers.website IS 'URL for website';
COMMENT ON COLUMN MBMBD1R31.suppliers.rating IS 'rating is from 1 (lowest) to 5(highest) stars';

CREATE TABLE MBMBD1R31.cafes_suppliers
(
    cafe_id NUMBER, 
    supplier_id NUMBER,
    contract_start_date DATE NOT NULL,
    contract_months NUMBER(2,0) NOT NULL,
    contract_value NUMBER(7,2) NOT NULL,
    
    CONSTRAINT cafes_suppliers_fk1 FOREIGN KEY (cafe_id) REFERENCES MBMBD1R31.cafes(cafe_id),
    CONSTRAINT cafes_suppliers_fk2 FOREIGN KEY (supplier_id) REFERENCES MBMBD1R31.suppliers(supplier_id),
    CONSTRAINT cafes_suppliers_pk PRIMARY KEY (cafe_id, supplier_id),
    CONSTRAINT contract_months_ck CHECK (contract_months > 0),
    CONSTRAINT contract_value_ck CHECK (contract_value > 0)   
);
COMMENT ON COLUMN MBMBD1R31.cafes_suppliers.contract_months IS 'duration of contract in months, beginning from start date'



/* Index on cafe_name in cafes table. It can be useful when we want to retrieve informations about a chain of 
cafes like Starbuck or 5ToGo, which have the same name, but different adresses */
CREATE INDEX idx_cafes_cafe_name ON MBMBD1R31.cafes(cafe_name);

/* Index on delivered_products in suppliers table. Useful when we need all suppliers that deliver 
a particular product*/
CREATE INDEX idx_suppliers_delivered_products ON MBMBD1R31.suppliers(delivered_products);

/* Index on rating in suppliers table. 
In descending order because we are interested in suppliers with higher ratings*/
CREATE INDEX idx_suppliers_rating_desc ON MBMBD1R31.suppliers(rating DESC);

// Indexes on FKs 
CREATE INDEX idx_fk_cafes ON MBMBD1R31.cafes_suppliers(cafe_id);
CREATE INDEX idx_fk_suppliers ON MBMBD1R31.cafes_suppliers(supplier_id);

/* 2. Creati un tabel cu structura si datele tabelului "studenti" din schema MASTER. Evidentiati
pasii prin care ati rezolvat cerinta (ce comenzi ati rulat)  (0.5p) */
-- Pas 1. Facem select pentru a vedea coloanele tabelei  
SELECT * FROM MASTER.studenti

-- Pas 2. Cream tabela studenti cu aceeasi structura
 CREATE TABLE MBMBD1R31.studenti 
   ("NUME" CHAR(30 BYTE), 
	"PRENUME" CHAR(30 BYTE), 
	"CNP" CHAR(13 BYTE), 
	"COD_SECTIA" NUMBER(3,0), 
	"DENUMIRE_SECTIA" VARCHAR2(70 BYTE), 
	"AN_STUDIU" NUMBER(1,0), 
	"GRUPA" CHAR(10 BYTE), 
	"MEDIA" NUMBER(5,2)
   );
   
-- Pas 3 - Varianta 1 cu Merge
MERGE INTO MBMBD1R31.studenti s1
USING (SELECT nume, prenume, cnp, cod_sectia, denumire_sectia, an_studiu, grupa, media FROM MASTER.studenti) s2
ON (s1.cnp = s2.cnp)
WHEN MATCHED THEN
    UPDATE SET s1.nume = s2.nume, 
               s1.prenume = s2.prenume, 
               s1.cod_sectia = s2.cod_sectia, 
               s1.denumire_sectia = s2.denumire_sectia, 
               s1.an_studiu = s2.an_studiu, 
               s1.grupa = s2.grupa, 
               s1.media = s2.media
WHEN NOT MATCHED THEN
    INSERT (nume, prenume, cnp, cod_sectia, denumire_sectia, an_studiu, grupa, media) 
    VALUES (s2.nume, s2.prenume, s2.cnp, s2.cod_sectia, s2.denumire_sectia, s2.an_studiu, s2.grupa, s2.media);

TRUNCATE TABLE MBMBD1R31.studenti

-- Pas 3 - Varianta 2
INSERT INTO  MBMBD1R31.studenti
SELECT * FROM MASTER.studenti;

-- Verificare
SELECT COUNT(*) FROM MASTER.studenti;
SELECT COUNT(*) FROM MBMBD1R31.studenti;




